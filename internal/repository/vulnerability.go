package repository

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/atta/vulnpulse/internal/domain"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
)

// VulnerabilityRepository handles vulnerability data operations
type VulnerabilityRepository struct {
	db *pgxpool.Pool
}

// NewVulnerabilityRepository creates a new vulnerability repository
func NewVulnerabilityRepository(db *pgxpool.Pool) *VulnerabilityRepository {
	return &VulnerabilityRepository{db: db}
}

// Create creates a new vulnerability
func (r *VulnerabilityRepository) Create(ctx context.Context, vuln *domain.Vulnerability) error {
	affectedProducts, err := json.Marshal(vuln.AffectedProducts)
	if err != nil {
		return fmt.Errorf("failed to marshal affected products: %w", err)
	}

	query := `
		INSERT INTO vulnerabilities (id, cve_id, title, description, severity, affected_products, published_at, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, NOW(), NOW())
		ON CONFLICT (cve_id) DO UPDATE
		SET title = EXCLUDED.title, description = EXCLUDED.description,
		    severity = EXCLUDED.severity, affected_products = EXCLUDED.affected_products,
		    published_at = EXCLUDED.published_at, updated_at = NOW()
		RETURNING created_at, updated_at
	`
	err = r.db.QueryRow(ctx, query, vuln.ID, vuln.CveID, vuln.Title, vuln.Description,
		vuln.Severity, affectedProducts, vuln.PublishedAt).
		Scan(&vuln.CreatedAt, &vuln.UpdatedAt)
	if err != nil {
		return fmt.Errorf("failed to create vulnerability: %w", err)
	}
	return nil
}

// GetByID retrieves a vulnerability by ID
func (r *VulnerabilityRepository) GetByID(ctx context.Context, id uuid.UUID) (*domain.Vulnerability, error) {
	query := `
		SELECT id, cve_id, title, description, severity, affected_products, published_at, created_at, updated_at
		FROM vulnerabilities
		WHERE id = $1
	`
	var vuln domain.Vulnerability
	var affectedProducts []byte
	err := r.db.QueryRow(ctx, query, id).Scan(
		&vuln.ID, &vuln.CveID, &vuln.Title, &vuln.Description, &vuln.Severity,
		&affectedProducts, &vuln.PublishedAt, &vuln.CreatedAt, &vuln.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get vulnerability: %w", err)
	}

	if err := json.Unmarshal(affectedProducts, &vuln.AffectedProducts); err != nil {
		return nil, fmt.Errorf("failed to unmarshal affected products: %w", err)
	}

	return &vuln, nil
}

// GetByCVE retrieves a vulnerability by CVE ID
func (r *VulnerabilityRepository) GetByCVE(ctx context.Context, cveID string) (*domain.Vulnerability, error) {
	query := `
		SELECT id, cve_id, title, description, severity, affected_products, published_at, created_at, updated_at
		FROM vulnerabilities
		WHERE cve_id = $1
	`
	var vuln domain.Vulnerability
	var affectedProducts []byte
	err := r.db.QueryRow(ctx, query, cveID).Scan(
		&vuln.ID, &vuln.CveID, &vuln.Title, &vuln.Description, &vuln.Severity,
		&affectedProducts, &vuln.PublishedAt, &vuln.CreatedAt, &vuln.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get vulnerability: %w", err)
	}

	if err := json.Unmarshal(affectedProducts, &vuln.AffectedProducts); err != nil {
		return nil, fmt.Errorf("failed to unmarshal affected products: %w", err)
	}

	return &vuln, nil
}

// List lists all vulnerabilities with optional filtering
func (r *VulnerabilityRepository) List(ctx context.Context, severity string, limit, offset int) ([]*domain.Vulnerability, error) {
	var query string
	var args []interface{}

	if severity != "" {
		query = `
			SELECT id, cve_id, title, description, severity, affected_products, published_at, created_at, updated_at
			FROM vulnerabilities
			WHERE severity = $1
			ORDER BY published_at DESC NULLS LAST, created_at DESC
			LIMIT $2 OFFSET $3
		`
		args = []interface{}{severity, limit, offset}
	} else {
		query = `
			SELECT id, cve_id, title, description, severity, affected_products, published_at, created_at, updated_at
			FROM vulnerabilities
			ORDER BY published_at DESC NULLS LAST, created_at DESC
			LIMIT $1 OFFSET $2
		`
		args = []interface{}{limit, offset}
	}

	rows, err := r.db.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to list vulnerabilities: %w", err)
	}
	defer rows.Close()

	var vulns []*domain.Vulnerability
	for rows.Next() {
		var vuln domain.Vulnerability
		var affectedProducts []byte
		err := rows.Scan(
			&vuln.ID, &vuln.CveID, &vuln.Title, &vuln.Description, &vuln.Severity,
			&affectedProducts, &vuln.PublishedAt, &vuln.CreatedAt, &vuln.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan vulnerability: %w", err)
		}

		if len(affectedProducts) > 0 {
			if err := json.Unmarshal(affectedProducts, &vuln.AffectedProducts); err != nil {
				return nil, fmt.Errorf("failed to unmarshal affected products: %w", err)
			}
		}

		vulns = append(vulns, &vuln)
	}

	return vulns, nil
}
