package handlers

import (
	"context"
	"encoding/json"
	"net/http"
	"strconv"
	"time"

	"github.com/atta/vulnpulse/internal/domain"
	"github.com/atta/vulnpulse/internal/repository"
	"github.com/atta/vulnpulse/pkg/logger"
	"github.com/atta/vulnpulse/pkg/queue"
	"github.com/google/uuid"
	"github.com/gorilla/mux"
)

// VulnerabilityHandler handles vulnerability endpoints
type VulnerabilityHandler struct {
	repo  *repository.VulnerabilityRepository
	queue *queue.Client
	log   *logger.Logger
}

// NewVulnerabilityHandler creates a new vulnerability handler
func NewVulnerabilityHandler(repo *repository.VulnerabilityRepository, queueClient *queue.Client, log *logger.Logger) *VulnerabilityHandler {
	return &VulnerabilityHandler{
		repo:  repo,
		queue: queueClient,
		log:   log,
	}
}

type IngestVulnerabilityRequest struct {
	CveID            string                   `json:"cve_id"`
	Title            string                   `json:"title"`
	Description      string                   `json:"description"`
	Severity         string                   `json:"severity"`
	AffectedProducts []domain.AffectedProduct `json:"affected_products"`
	PublishedAt      *time.Time               `json:"published_at,omitempty"`
}

// Ingest creates or updates a vulnerability
func (h *VulnerabilityHandler) Ingest(w http.ResponseWriter, r *http.Request) {
	var req IngestVulnerabilityRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "invalid request", http.StatusBadRequest)
		return
	}

	// Validate severity
	if req.Severity != domain.SeverityCritical && req.Severity != domain.SeverityHigh &&
		req.Severity != domain.SeverityMedium && req.Severity != domain.SeverityLow {
		http.Error(w, "invalid severity", http.StatusBadRequest)
		return
	}

	vuln := &domain.Vulnerability{
		ID:               uuid.New(),
		CveID:            req.CveID,
		Title:            req.Title,
		Description:      req.Description,
		Severity:         req.Severity,
		AffectedProducts: req.AffectedProducts,
		PublishedAt:      req.PublishedAt,
	}

	if err := h.repo.Create(r.Context(), vuln); err != nil {
		h.log.Error("failed to ingest vulnerability", "error", err)
		http.Error(w, "failed to ingest vulnerability", http.StatusInternalServerError)
		return
	}

	// Publish vuln.ingested job for matching
	h.publishVulnIngested(r.Context(), vuln.ID)

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(vuln)
}

// List lists all vulnerabilities with optional filtering
func (h *VulnerabilityHandler) List(w http.ResponseWriter, r *http.Request) {
	severity := r.URL.Query().Get("severity")
	limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
	offset, _ := strconv.Atoi(r.URL.Query().Get("offset"))

	if limit == 0 {
		limit = 50
	}

	vulns, err := h.repo.List(r.Context(), severity, limit, offset)
	if err != nil {
		h.log.Error("failed to list vulnerabilities", "error", err)
		http.Error(w, "failed to list vulnerabilities", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"vulnerabilities": vulns,
		"count":           len(vulns),
		"limit":           limit,
		"offset":          offset,
	})
}

// Get retrieves a vulnerability by ID
func (h *VulnerabilityHandler) Get(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := uuid.Parse(vars["id"])
	if err != nil {
		http.Error(w, "invalid vulnerability ID", http.StatusBadRequest)
		return
	}

	vuln, err := h.repo.GetByID(r.Context(), id)
	if err != nil {
		http.Error(w, "vulnerability not found", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(vuln)
}

func (h *VulnerabilityHandler) publishVulnIngested(ctx context.Context, vulnID uuid.UUID) {
	msg := queue.Message{
		Type:     "vuln.ingested",
		TenantID: "", // Will match against all tenants
		Payload: map[string]interface{}{
			"vulnerability_id": vulnID.String(),
		},
	}
	if err := h.queue.Publish(ctx, "vulnpulse-jobs", msg); err != nil {
		h.log.Error("failed to publish vuln.ingested event", "error", err)
	}
}
